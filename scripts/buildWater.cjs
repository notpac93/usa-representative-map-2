const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const inputInfo = {
    input: 'data/raw/naturalearth/ne_10m_lakes/ne_10m_lakes.shp',
    clip: 'data/raw/cb_2023_us_state_5m/cb_2023_us_state_5m.shp',
    out: 'data/overlays/water.generated.ts',
    key: 'water-bodies',
    label: 'Water & Lakes'
};

console.log('[buildWater] Starting robust custom water build...');

const tmpMajorLakes = 'tmp_major_lakes.geojson';
const tmpGreatLakes = 'tmp_great_lakes.geojson';
const tmpClipped = 'tmp_water_clipped.geojson';
const tmpCombined = 'tmp_water_combined.geojson';

try {
    // 1. Extract Great Lakes by SCALERANK + GEOMETRY (BBox)
    // Great Lakes Area BBox: xmin: -93, ymin: 41, xmax: -75, ymax: 49
    // Scalerank <= 1 ensures we only get the massive lakes (Superor, Huron, Michigan, Erie, Ontario)
    // and avoid smaller lakes in that box if any.
    console.log('[buildWater] Extracting Great Lakes via Geometry...');

    // Filter for large lakes first
    // Note: scalerank is integer.
    execSync(`npx mapshaper -i "${inputInfo.input}" -filter "scalerank <= 1" -o ${tmpMajorLakes}`, { stdio: 'inherit' });

    // Filter by bounding box.
    // Instead of js expression which might fail on projection issues, use -clip bbox=... which returns features overlapping.
    console.log('[buildWater] Clipping major lakes to Great Lakes Box...');
    const bbox = "-93,41,-74.5,49";
    execSync(`npx mapshaper -i ${tmpMajorLakes} -clip bbox=${bbox} -o ${tmpGreatLakes}`, { stdio: 'inherit' });

    // 2. Clip all lakes to US border (Removes Canada/Mexico lakes)
    console.log('[buildWater] Clipping all lakes to US border...');
    execSync(`npx mapshaper -i "${inputInfo.input}" -clip "${inputInfo.clip}" remove-slivers -o ${tmpClipped}`, { stdio: 'inherit' });

    // 3. Combine them
    // This merges the "Clipped US Lakes" with the "Full Great Lakes".
    console.log('[buildWater] Combining layers and dissolving overlaps...');
    execSync(`npx mapshaper -i ${tmpGreatLakes} ${tmpClipped} combine-files -merge-layers -dissolve -simplify visvalingam 2% keep-shapes -o format=geojson precision=0.0001 ${tmpCombined}`, { stdio: 'inherit' });

    // 4. Wrap into TS
    if (fs.existsSync(tmpCombined)) {
        const geojson = fs.readFileSync(tmpCombined, 'utf8');
        const parsed = JSON.parse(geojson);

        // Handle Mapshaper output quirks: single Feature vs Collection vs Geometry
        let features = [];
        if (parsed.type === 'FeatureCollection') {
            features = parsed.features;
        } else if (parsed.type === 'Feature') {
            features = [parsed];
        } else if (parsed.type === 'GeometryCollection') {
            // Wrap geometries into features?
            features = parsed.geometries.map((g, i) => ({
                type: 'Feature',
                id: i,
                properties: {},
                geometry: g
            }));
        } else {
            // Single raw geometry?
            features = [{ type: 'Feature', properties: {}, geometry: parsed }];
        }

        console.log(`[buildWater] Generated ${features.length} features.`);

        const layer = {
            key: inputInfo.key,
            label: inputInfo.label,
            category: 'Base',
            fill: '#a3ccf1',
            stroke: 'transparent',
            strokeWidth: 0,
            lineCap: 'round',
            hidden: true,
            renderOrder: -20,
            features: features
        };

        const banner = '// AUTO-GENERATED by scripts/buildWater.cjs\n';
        const content = `${banner}import type { OverlayLayer } from '../../types';\nexport const waterOverlay: OverlayLayer = ${JSON.stringify(layer, null, 2)};\nexport default waterOverlay;\n`;

        fs.writeFileSync(inputInfo.out, content);
        console.log(`[buildWater] Wrote ${inputInfo.out}`);
    } else {
        throw new Error('Failed to generate combined geojson');
    }

} catch (err) {
    console.error('[buildWater] Error:', err);
    process.exit(1);
} finally {
    // Cleanup
    [tmpMajorLakes, tmpGreatLakes, tmpClipped, tmpCombined].forEach(f => {
        if (fs.existsSync(f)) fs.unlinkSync(f);
    });
}
