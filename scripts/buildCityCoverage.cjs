#!/usr/bin/env node
/**
 * buildCityCoverage.cjs
 *
 * Generates a TypeScript module summarizing per-state city coverage based on the
 * current overlay and a reference source dataset (Gazetteer or TIGER places).
 */

const fs = require('fs');
const path = require('path');
const { runCityCoverage } = require('./verifyCitiesCompleteness.cjs');

const args = parseArgs(process.argv.slice(2));
const outFile = args.out || 'data/cityCoverage.generated.ts';
const options = {
  overlay: args.overlay,
  source: args.source || args.input || args.tiger,
  minPop: args.minpop !== undefined ? Number(args.minpop) : 0,
  funcstat: args.funcstat || args.status || 'A',
  popcsv: args.popcsv,
  silent: true,
};

try {
  const summary = runCityCoverage(options);
  const payload = buildPayload(summary);
  writeModule(outFile, payload);
  console.log(`City coverage written to ${outFile}`);
} catch (err) {
  console.error('[buildCityCoverage] Failed:', err?.message || err);
  process.exit(1);
}

function parseArgs(list) {
  const parsed = {};
  for (let i = 0; i < list.length; i++) {
    const token = list[i];
    if (!token.startsWith('--')) continue;
    const key = token.slice(2);
    const next = list[i + 1];
    if (next && !next.startsWith('--')) {
      parsed[key] = next;
      i++;
    } else {
      parsed[key] = true;
    }
  }
  return parsed;
}

function buildPayload(summary) {
  const perState = summary.perState.reduce((acc, state) => {
    acc[state.state] = {
      state: state.state,
      stateName: state.stateName,
      source: state.source,
      covered: state.covered,
      coverage: Number(state.coverage || 0),
      missingExamples: state.missingExamples,
    };
    return acc;
  }, {});

  const meta = {
    generatedAt: new Date().toISOString(),
    overlayPath: summary.overlayPath,
    sourcePath: summary.sourcePath,
    minPopulation: summary.minPopulation,
    funcstatFilter: summary.funcstatFilter,
    overlayFeatureCount: summary.overlayFeatureCount,
    sourceFeatureCount: summary.sourceFeatureCount,
    coverageRatio: summary.coverageRatio,
    topMissing: summary.topMissing.map(item => ({
      id: item.id || null,
      name: item.name,
      stateAbbr: item.stateAbbr || null,
      stateName: item.stateName || null,
      population: typeof item.population === 'number' ? item.population : null,
    })),
  };

  return { perState, meta };
}

function writeModule(outFile, payload) {
  const banner = '// AUTO-GENERATED by buildCityCoverage.cjs. DO NOT EDIT.\n';
  const typesImport = getTypesImport(outFile);
  const content = `${banner}import type { CityCoverageMap, CityCoverageMeta } from '${typesImport}';\n\n` +
    `export const cityCoverageMeta: CityCoverageMeta = ${JSON.stringify(payload.meta, null, 2)};\n\n` +
    `export const cityCoverage: CityCoverageMap = ${JSON.stringify(payload.perState, null, 2)};\n\n` +
    `export default cityCoverage;\n`;
  fs.mkdirSync(path.dirname(outFile), { recursive: true });
  fs.writeFileSync(outFile, content);
}

function getTypesImport(outFile) {
  const rel = path.relative(path.dirname(outFile), path.join('types')).replace(/\\/g, '/');
  return rel.startsWith('.') ? rel : `./${rel}`;
}
